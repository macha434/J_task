2008.5.30 和崎

H8/300H シリーズの開発環境について

○クロスコンパイラ、ライブラリ等の準備
以下の HP を参考に。
	http://strawberry-linux.com/h8/linux.php
必要なもの
	binutils(アセンブラ、リンカなど)
	gcc(コンパイラ)
	newlib(ライブラリ)
		binutils-2.11.2.tar.gz (9,702KB)
		gcc-2.95.3.tar.gz (12,609KB) + gcc-2.95.2-20011211.diff
		newlib-1.9.0.tar.gz (3,288KB)
binutils のコンパイル
	$ cd binutils-2.11.2
	$ mkdir build
	$ cd build
	$ ../configure --target=h8300-hms --prefix=/usr/local/h8
	$ su
	$ make
	$ make install
	/usr/local/h8 以下にクロスアセンブラ・リンカなどのバイナリ
	ツールが作成されます。/usr/local/h8/bin に実行ファイルが置か
	れるので、必ず PATH に /usr/local/h8/bin を追加してあげてください。
	.cshrcや.bashrc等に記述しておけば次回ログインからすぐ利用できます。
gcc のコンパイル
	gcc-2.95.2/3 で H8tiny (H8/3664 シリーズ) のプログラムを作成すると
	引数が正しく渡せない問題が生じます。それを修正するのがパッチです。
	$ cd gcc-2.95.2
	$ cat gcc-2.95.2-20011211.diff | patch -p1
	$ mkdir build
	$ cd build
	$ su
	$ ../configure --target=h8300-hms --prefix=/usr/local/h8 \
	--with-newlib --with-headers=<dir>/newlib-1.9.0/newlib/libc/include
	$ make LANGUAGES="c"
	$ make LANGUAGES="c" install
	<dir> には newlib-1.9.0 を解凍したディレクトリをフルパスで
	入力します。
	例 /home/ochiai/h8/
newlib のコンパイル
	$ cd newlib-1.9.0
	$ mkdir build
	$ cd build
	$ ../configure --target=h8300-hms --prefix=/usr/local/h8
	$ make
	$ su
	$ make install
	
○デバッキング環境の整備
  デバッキングは GDB で行う。これもh8/300H用にコンパイルする。
  パッチをあてないと正常に動作しないので注意。
  デバッキングは、GDB 内蔵のシミュレータで行う方法と、ターゲットマシン
  上で行うリモートデバッキングの方法がある。
  アセンブラの課題等は、実機ではかえってやりづらいので、シミュレータ上
  で行った方がよい。
  実機を使った演習課題などは、リモートデバッキングを行った方が目で見て
  デバッグができるのでわかりやすい。
必要なもの
	gdb-5.2.1
	gdb-5.2.1.diff
	h8-stub
gdbのコンパイル
	パッチをgdb-5.2.1の直下に置いて、先にパッチをあてる。
	$ patch -p1 < gdb-5.2.1.diff
	$ mkdir build
	$ cd build
	$ su
	$ ../configure --target=h8300-hms --prefix=/usr/local/h8
	$ make
	$ make install
h8-stubのコンパイル
	$ make

○マイコンボード側の準備
  マイコンボードに書き込まれている S フォーマットローダでは、データの
  フォーマット形式が厳格すぎて、作成したファイルを転送しても受け付けて
  くれない。また、常に SCI1 からデータをダウンロードしようとするため、
  USB ケーブルと E ケーブルの2本が必要となる。更に、E ケーブルは断線し易く
  扱い難い。このため、別の S フォーマットローダを焼き直す。

	ダウンローダ：loader.mot (Sフォーマット形式)

  このダウンローダは、USB ポートから RAM 上にプログラムを転送し、実行する
  のは同じだが、改行コード等についてロバストにできており、SCI0 から
  ダウンロードをするようになっているため、接続も USB ケーブルのみで OK。

  ルネサスから無償でツール(Windows 版)が提供されているので、それを使用
  するか、フリーのツールが複数あるのでそれを利用して焼き直す。
  学習ボードに電源を供給するために、USB ケーブルで PC と接続する。実際の
  データの転送は、学習ボードに付属のEケーブルで行う。
  プログラムをマイコンに焼くときは、シリアルポートを持つPCが必要となる
  ので注意のこと。USB-シリアル変換器を挟むと、うまく焼けない。
  また、プログラムを焼く場合は、マイコン側の SCI1 から受け付けるように
  なっているので注意する。

  1. ケーブルの接続
     ・ USB ケーブルで、学習ボードと PC を接続する。
     ・ E ケーブルで、学習ボード上のCPUボード(CN5)と PC のシリアルポートに
       接続する。
  2. 学習ボードのスイッチの操作
     ・CPUボード上にある以下のスイッチを切替える。
	ロックスイッチ SW4 (1 連 DIP スイッチ)を OFF にする
		→ CPU のモードが自動的に変更される
	トグルスイッチSW3(トグルスイッチ)をFW側(向かって右側)に倒す
		→ 書き込みモードに変更、SW3 左横の D3 が点灯する
     ・［書き込みツールの実行］
	書き込み方法は、各ツールの説明にしたがうこと。
	焼くローダは、loader.mot を指定のこと。
     ・CPUボード上の変更したスイッチを元に戻す。(*** 必須 ***)
	トグルスイッチ SW3 (トグルスイッチ)を向かって左側に倒す
		→ SW3 左横の D3 が消灯する
	ロックスイッチSW4(1 連 DIP スイッチ)を ON にする


○開発環境の使用方法
・ハードウェアの準備
	マイコン学習ボード + USB 接続ケーブル
	電源は USB ポートから供給するので、外付け不要。

	マイコン学習ボードの USB ポートは、USB-シリアル変換ICを通して
	マイコンボードの SCI0 に接続されている。ダウンローダや GDB との
	やりとりはこれを使って行う。(SCI1 からはできない!)

	シリアル変換ICのドライバは、Windows と Linux の両方でデフォルトで
	もっている。Windows + VMware の構成でも認識OK。
	USB ケーブルを接続すると、自動的に認識される。Linuxでは、
		/dev/ttyUSB0
	として認識される。(他に USB 機器があるときは、末尾の番号が変わる)

・ユーザプログラムの作成
	普通に emacs を使用して、C 言語またはアセンブリ言語で記述する。
	［作成上の注意点］
		・stdio.h をインクルードしないこと。
		・printf, scanf などの入出力はサポートしていない。
		・以下のプログラム等を提供する
			I/O 定義ヘッダファイル(h8-3052-iodef.h)
			Makefile の雛型(Makefile)
			スタートアップルーチン(ramcrt*.s, romcrt*.s)
			リンカスクリプト(h8-3052-*.x)
		・必要なヘッダファイルだけをインクルード指定すること。

	Makefile の雛型の中身を作成したプログラムの構成にあわせて変更し、
	別名で保存(例えば、make-test)する。
	make の実行は、
		make -f make-test [clean]
	として行う。必要なスタートアップルーチンやリンカスクリプトの
	選択は、makefile 中の指定に応じて自動的に行われる。

	最終的には、メインプログラムとして指定した名前.mot ができるので、
	それを転送することになる。
	なお、リモートデバッキングのときは、指定した名前.coff を使用す
	ることになる。

・プログラムの転送
	マイコン学習ボードにプログラムを転送するには、以下の手順で行う。

		・USBデバイスの各種設定
			setcom を実行する(最初に1度だけでよい)
			中身は stty コマンドによる通信制御なので、必要
			に応じてデバイス名や各属性を書き換えること

		・コマンドウィンドウを2つ開く
			一つは転送するためのウィンドウ
			一つは転送を確認するためのウィンドウ

		・確認するウィンドウを受信専用にする
			cat /dev/ttyUSB0
			これで、USB ポートから送られてくる文字列がその
			ままコマンドウィンドウ上に表示される

		・ CPU ボード上のリセットスイッチ(SW2)を押す
			確認ウィンドウ側にメッセージが表示される
			<例>
			S-format Loader (by H.Wasaki)
			  38400 baud, Non-parity, 1-Stop bit
			Ready for data receive :

		・転送するウィンドウでプログラムを転送する
			cat ****.mot > /dev/ttyUSB0
			これで、プログラムが転送される。
			(****.mot が転送したいプログラム)
			確認するウィンドウ側に転送されたプログラムの
			中身がそのまま表示される

		・転送が終了した時点で、自動的に実行開始

		・リセットスイッチを押すと、常にローダが実行される

	なお、転送確認用のウィンドウは必須ではないので、なくてもよい。

・ GDB を使ったデバッキングの方法
  内蔵シミュレータを使う方法と、リモートデバッキングの方法がある。
  リモートデバッキングでは、実機が必ず必要となるので、割り込み処理
  などがないプログラムでは、前者の方法が使い易い。
  また、GDB 本体だけでデバッキングを行うのは、ブレークポイントの設定な
  どが面倒になるので、emacs または ddd を利用するのがよい。
  emacs は CUI、ddd は GUI になるので ddd の方が使い易いが、日本語表示に
  対応していない(全角文字が化ける)欠点がある。
	○内蔵シミュレータを使う方法
	  GDB が持っている H8/300H のシミュレータでデバッキングを行う。
		・ GDB の起動
			h8300-hms-gdb (ターミナル上、CUI) ※勧めない
			emacsを起動し、Esc-x gdb          ※標準的
			  Run gdb (like this): には h8300-hms-gdb
			  画面が2つになって、下側半分にGDBが起動する
			ddd --debugger h8300-hms-gdb & (DDD で GUI 環境)
							  ※便利
		  なお、gdb や ddd だけで起動すると、ホストの gdb が起動
		  してしまうので注意すること。

		・シンボルテーブルの読み込み
		  デバッガに必要な情報の読み込み：file コマンド
			(gdb) file test-port.coff
			Reading symbols from test-port.coff...done.

		・ターゲットの指定
		  デバッグする対象を指定する：target コマンド
			(gdb) target sim
			SCI0 = /dev/pts/2
			Connected to the simulator.

		・プログラムの指定
		  プログラムのロード：load コマンド
		  必ず、実行可能形式である ****.coff を指定すること
			(gdb) load test-port.coff
			Loading section .vectors, size 0x100 vma 0xffe100
			Loading section .text, size 0x68 vma 0x200000
			Start address 0x200000
			Transfer rate: 2880 bits in <1 sec.

		・ブレークポイントの設定
			emacs の場合は、ソースファイルを表示させて
				C-x spc
			で簡単にブレークポイントを設定できる。
			ddd の場合は、ソースファイルとアセンブラが表示
			されているので、ソース上にカーソルを合わせて
			BREAK ボタンをクリックするだけよい。
			設定する度に
			Breakpoint 1 at 0x200026: file test-port.c, line 12.
			Breakpoint 2 at 0x200038: file test-port.c, line 15.
			のようなメッセージが出る

		・実行
		  プログラムの実行コマンド：run
			(gdb) run
			Starting program: test-port.coff

		・ブレークポイント時の表示と便利なコマンドなど
			Breakpoint 1, main () at test-port.c:12
			(gdb)
			○値の確認：xコマンド
			(gdb) x $pc  ← プログラムカウンタ
			0x200026 <main+26>:	0xfa2068ca
			(gdb) x 0xffffd2  ← 0xffffd2 の内容
			0xffffd2:	0x00000000  ← 4 バイト長
			(gdb) x/bx 0xffffd2  ← /bx で 1 バイトで表示
			0xffffd2:	0x00
			(gdb) 
			○引き続き実行する：continue コマンド
			(gdb) c
			Continuing.
			○ソースの1行ずつ実行する：step コマンド
			(gdb) s

		・実行を強制的に止めたいとき
			C-c C-c (emacs 上で CTRL-c を2回)
			Program received signal SIGINT, Interrupt.
			0x0020005a in time_wait (loop=500) at test-port.c:24
			(gdb)

		・gdbの終了
			終了：quit コマンド
			(gdb) q
			The program is running.  Exit anyway? (y or n) y
			Debugger finished

	  ブレークポイントで停止したり、強制的に実行を止めると、停止した
	  アドレスなどを表示するとともに、ソースプログラムの該当する行
	  に何らかの印がつく。

	○リモートデバッキングの方法
	［概要］
	  リモートデバッキングは、コードの実行は実機上で行われるので、
	  実際の環境そのままでデバッキングできる利点がある。
	  GDB を使う以上、実機の状態(レジスタやメモリの値など)を何らか
	  の方法でホスト側と通信して情報を GDB とやりとりする必要がある。
	  また、任意に設定されるブレークポイントでプログラムを停止させ
	  るような仕組みが必要となる。

	  すなわち、情報をやりとりするための通信の仕組みと、ユーザ
	  プログラムを任意の位置で停止させるための仕組みが必要となる。
	  ブレークポイントをユーザのソースプログラムに関数として埋め込
	  んで呼び出す方法もあるが、ブレークポイントを新たに設定する度
	  にコンパイルする必要があって使い勝手が悪い。

	  そこで、ブレークポイントに指定された命令を TRAP に置き換えて
	  その割り込みを契機として GDB 側に制御が移るような仕組みを
	  とっている。このように、命令を置き換えたり情報の通信をするには、
	  ターゲットマシン上にそのような機能をもったプログラムを置いて
	  おく必要があり、そのプログラムを GDB ではスタブと呼んでいる。

	  割り込み処理については、割り込みベクタを全てスタブが管理し、
	  ユーザプログラムの割り込みベクタは、仮想ベクタとして RAM 上に
	  配置される。割り込みがユーザプログラム上で発生すると、スタブ
	  に制御が移り、仮想ベクタから実行すべきアドレスを求めて実行の
	  継続が行われる。(TRAP や MNI、SCI0 などの割り込みには特別な
	  役割が設定されているので注意。当然、これらの割り込みを使った
	  プログラムのリモートデバッグはできない。)

	  スタブはターゲットマシン上で動かなければならず、また割り込み
	  等の処理や通信ハードウェアの依存性のため、各 CPU やボード毎に
	  異なるものを準備しなければならない。これについては、H8/3069
	  (秋月電子製ボード用)があったので、それを改造して作成した。
	  H8 シリーズは I/O やベクタアドレスなどが異なるが、その他は
	  ほとんど差異がないため、コアの部分には手をつけずに済んだ。
	  修正は割り込みベクタ関係程度である。
	  
	  また、通常はスタブは固定的にターゲットマシン上に置かれるが、
	  この場合にはデバッキング専用のターゲットマシンを準備すること
	  になり、実験実習では複数のターゲットを準備するのは難しくなる。
	  このため、ターゲットマシンには S フォーマットローダのみを置
	  き、スタブをローダを使って RAM 上に展開して実行する。一旦、
	  スタブが動作して GDB と接続が確立されれば、GDB からスタブ経由
	  でユーザプログラムをターゲットマシンに転送して実行することが
	  可能となる。
	  但し、このときのユーザプログラムの割り込みベクタを置く位置は
	  実機上のベクタアドレス上ではないため、リンク時に通常とは異な
	  る位置(スタブで仮想ベクタとして設定したアドレス)に置かれるよ
	  うなリンカスクリプト(h8-3052-ram-dbg.x)が必要となる。このた
	  め、makefile 中にリモートデバッキング用の coff を作成出来る
	  ようなオプション(REMOTE_DBG)を用意した。

	  通常のメモリマップ
	  000000 - 0000ff 内蔵 ROM 領域、実機の割り込みベクタ
			  (ローダの割り込みベクタ)
	  000100 - 07ffff 内蔵 ROM 領域、プログラム領域
	       ( - 000690 ローダプログラムの入っている領域)
	  200000 - 21ffff 外部 RAM 領域
	       ( 200000 - ユーザプログラム、変数領域)
	       ( - 21ffff ユーザプログラムのスタック領域)
	  ffdf10 - ffff0f 内部 RAM 領域(RAM エミュレーション領域を含む)
	       ( - ffff0f ローダの変数、スタック領域)
	  ffe000 - ffefff ←→ 000000 - 000fff RAM エミュレーション時
	  ffe000 - ffe0ff ユーザプログラムのベクタ領域

	  リモートデバッキング用のメモリマップ
	  000000 - 0000ff 内蔵 ROM 領域、実機の割り込みベクタ
			  (ローダの割り込みベクタ)
	  000100 - 07ffff 内蔵 ROM 領域、プログラム領域
	       ( - 000690 ローダプログラムの入っている領域)
	  200000 - 21ffff 外部 RAM 領域
	       ( 200000 - ユーザプログラム、変数領域)
	       ( - 21f6ff ユーザプログラムのスタック領域)
	 (21f700 - 21ffff スタブの変数領域)
	  ffdf10 - ffff0f 内部RAM領域(RAM エミュレーション領域を含む)
	       ( - ffff0f ローダの変数、スタック領域)
	  ffe000 - ffefff ←→ 000000 - 000fff RAMエミュレーション時
	  ffe000 - ffe0ff スタブのベクタ領域
	  ffe100 - ffe1ff ユーザプログラムの仮想ベクタ領域
	  ffe200 - fff90f スタブのプログラム領域
	  fff910 - ffff0f スタブのスタック領域

	  メモリマップの変更については、なるべくスタブの実行が速くなる
	  ように全てを内蔵 RAM 上に載せたかったが、大き過ぎて載らない
	  ので、変数領域のみを外部RAM上の最後に配置した。このため、
	  ユーザプログラムのスタック領域がその分だけ少なくなっている。

	  ちなみに、内蔵RAMと外部RAMでは、メモリアクセス速度が異ってい
	  る。これは、内部バスは 16 ビット幅であるのに対して外部は
	  8 ビット幅であることと、アクセスステートが内部は 2 ステート
	  であるのに対して外部が 3 ステートであるためである。
	  このため、ステート数で 1.5 倍、バス幅で 2 倍、都合 3 倍も
	  アクセス速度が違うことになる。(ワードのアクセス時)

	○リモートデバッキングの手順
	  ・ユーザプログラムをリモートデバッキング用に make する
		Makefile 内の指定を変更する
			 REMOTE_DBG = true
		make する
	  ・スタブをマイコン学習ボードに転送・実行する
		転送するスタブは、h8-stub.mot
	  ・GDBを起動する
		ターゲットの指定
			(gbd) target remote /dev/ttyUSB0
			      /dev/ttyUSB0 はUSB接続しているデバイス
		ユーザプログラムの転送：(スタブを通じて転送される)
			(gdb) load ****.coff
			      ****.coff はユーザプログラム
			      (****.mot ではないことに注意)
		ブレークポイント等の設定は内蔵シミュレータの方法と同じ
	  ・動作の開始は continue コマンドで行う(run ではなくて)
		これはスタブの構造上の理由による

○実機上での実行の仕組み
  ・ H8/300H シリーズのスタートアップについて
    電源を入れた直後は、RESET 信号によってCPUの全ての状態(レジスタ群)
    を初期化する必要があるため、RESET 後に実行すべきプログラムがどこに
    あるかを知る術が必要である。
    一般的な方法としては、特定のアドレスに起動時に実行すべきプログラム
    のスタートアドレスを記述しておき、起動時にそのスタートアドレスを
    取得する。割り込みも同様である。

    RESET や割り込みに対応したスタートアドレスの集まりを割り込みベクタ
    といい、それらが置かれるアドレスを(割り込み)ベクタアドレスという。
    ベクタアドレスの内容は、それらが参照される前には設定されていなけれ
    ばならず、少なくともRESET ベクタに関しては ROM 領域内になければな
    らない。一般的に割り込みベクタはまとまったアドレスに置かれるので、
    ベクタアドレスは全て ROM 領域内に置かれているのが普通である。

    H8/300H シリーズでは、ベクタアドレスは 0 番地から置かれている。実
    際に扱えるアドレス空間の大きさは 24 ビットだが、命令の境界を偶数ア
    ドレスとするために、設定するベクタアドレスの大きさも 32 ビット、
    つまり 4 バイト長となっている。内部 I/O からの割り込みなどを含め、
    割り込みベクタの種類は 64 種類となっている。このことから、
		ベクタアドレス領域：0x000000 - 0x0000ff
		  (リセットベクタは 0x000000 - 0x000003)
    となっている。したがって、少なくとも RESET ベクタは、電源 ON 時に
    起動するプログラムの開始アドレスとなっていなければならない。当然、
    そのプログラムは ROM 領域内に存在していなければならない。

  ・ ROM エミュレーション機能について
    原則として、割り込みベクタは参照前に確定していなければならない。
    RESET については ROM のような固定的なデバイスに書き込んでおく必要
    があるが、その他の割り込みについては時としてベクタアドレスを変更し
    たい場合もある。この機能が内蔵 RAM による ROM エミュレーションであ
    り、RAMCR の設定で使用できるようになる。
    ROM エミュレーションを ON にすると、内蔵 ROM 領域の一部が内蔵 RAM
    領域の一部に置き換えられる。

    ＜例＞
	0x000000 - 0x000fff → 0xffe000 - 0xffefff 

    切替えた時点から、例えば 0 番地への参照は、0xffe000 番地への参照と
    なる。0xffe000 番地への参照は、そのまま 0xffe000 番地が参照される。
    切替えた時点でベクタアドレスの変更が有効となるため、切替える前に
    内蔵 RAM の 0xffe000 - 0xffe0ff に割り込みベクタをセットしておく必
    要がある。

    マイコン学習ボードの 内蔵 ROM には、割り込みベクタにローダの開始
    アドレスが書かれており、ローダは割り込みベクタの直後に置かれている。
	0x000000 : 0x000100  ← RESET ベクタの内容
	0x000100 - 0x00068f  ← ローダプログラム領域

    ユーザプログラムで割り込みを使用する場合は、それをロードした時点で
    割り込みベクタを書き換えなければならないが、ROM の内容を直接書き換
    えすることはできない。このため、ROM エミュレーション機能を使用して、
    ユーザプログラムの割り込みベクタを 0xffe000 から置いてから、
    ユーザプログラムの開始時に ROM エミュレーションを ON にするように
    している。なお、ユーザプログラムの開始アドレスは、S フォーマットの
    中に埋め込まれているので、ローダがそれを解釈して実行を開始する。

  ・オブジェクトの実行
    コンパイルされたオブジェクトは、先頭番地を 0 として生成されて OS
    が割り当てる主記憶に柔軟に対応できるように生成される。実行時には
    ローダがメモリ上にプログラムを配置して実行するわけだが、そもそも
    マイコン学習ボードのような小規模なシステムの場合は、OS が搭載され
    ていないので、どこに配置してどこから実行すべきかを決定する方法がな
    い。このため、固定的にリンカでメモリにロードするアドレスまで細かく
    指定する必要がある。リンカスクリプトはリンカに対して、何をどこに配
    置するかを指定するものであり、その内容はボードのメモリマップなどを
    考慮しながら決定しなければならない。

    作成したリンカスクリプト内では、ベクタ領域、コード領域、定数領域、
    変数領域、スタック領域の、実機上のアドレス空間への割り当てを行って
    いる。これらの領域割り当ては、プログラムをどのようにして実行させる
    かによっても変化し、例えば、ROM 領域にプログラムを置く場合と RAM
    領域に置く場合とでは、配置が異ってくる。マイコン学習ボード用にも
    複数のリンカスクリプトが用意されている(h8-3052-*****.x)のは、この
    ためである。但し、通常はユーザプログラムは外部 RAM 上に転送されて
    実行されるので、頻繁に変更する必要はない。

    また、別の問題としては、OS があれば例えばハードウェアに依存する初
    期化などは面倒を見てもらえるが、そうでなければプログラム側で全てを
    やらなければならない。
    スタックポインタのセットや外部バス制御の設定…など、マイコンとして
    動作するために必要な操作全ての面倒を見る必要がある。これを行うのが
    スタートアップルーチンの役割である。コンパイラが出力するコードは、
    すでにそれらが済んでいると仮定して生成されているので、単独では
    まともに実行できない。プログラムは必ずスタートアップルーチンをリン
    クしなければならず、プログラムの実行はスタートアップルーチンから実
    行が始まってメインプログラムへ実行が移る。
    これもプログラムをどのようにして実行させるかによって、その内容が違っ
    てくるので、それにあわせて複数のスタートアップルーチンを作成してあ
    る。

    これらのリンカスクリプトやスタートアップルーチンは、プログラムの実
    行形態に合わせて正しく選択しなければならないが、いちいち指定するの
    も大変なので、Makefile 内のオプションをセットすることによって自動
    的に選択されるように雛型を作成した。

○サンプルプログラム
  マイコン学習ボードには、LED、LCD、スピーカ(マイク兼用)、キースイッチ
  が搭載されている。これらの動作試験等を兼ねて、いくつかのサンプルプロ
  グラムを作成した。

  ・ LED の点滅プログラム
    マイコン学習ボード上の LED(D1：赤、D2：緑)を交互に点滅させるプログ
    ラム。点滅の時間間隔は、for ループによる無駄時間による。
	makefile : make-test-port
	メインプログラム：test-port.c
	その他プログラム：なし
	I/O 情報
		D1(LED赤)：P94 ('0':点灯、'1':消灯)
		D2(LED緑)：P95 ('0':点灯、'1':消灯)

  ・ LCD ランダム文字表示プログラム
     マイコン学習ボード上の LCD のランダムな位置にランダムな文字を表示
     し続けるプログラム。乱数発生は DRAM のタイマを利用して生成してい
     る。
	makefile : make-test-lcd
	メインプログラム  ：test-lcd.c
	LCD 制御プログラム：lcd.c 
	乱数発生プログラム：random.c
	I/O 情報
		PA4：LCD 制御線(E)
		PA5：LCD 制御線(R/W)
		PA6：LCD 制御線(RS)
		P40-P47：LCD データバス(DB0-DB7)

  ・タイマ割り込みを使った時計もどきプログラム
    タイマ割り込みを使って、1秒毎に LCD に時間を表示する。時間は割り込
    みがかかる度に、タイマ変数の値が 1 増加することで計時する。タイマ
    変数は整数なので、その値から時・分・秒を求めて文字列に再構成して
    LCD に表示している。
	makefile : make-clock
	メインプログラム    ：clock.c
	タイマ制御プログラム：timmer.c
	割り込み制御マクロ  ：h8int.h
	I/O 情報：なし

  ・キーボード読み込みとその表示プログラム
    マイコン学習ボード上のキーマトリクスをスキャンし、押されたキーに対
    応する文字(ボード上に印刷してある文字)を LCD に表示するプログラム。
    キースキャンは割り込みを使って、一定時間(1ms)毎に行ってバッファに
    入れる。割り込みが発生する度に、各キーの状態を調べて押されていたら
    対応する LCD の表示位置に対応する文字を表示する。
	makefile : make-keytest
	メインプログラム    ：keytest.c
	キー制御プログラム  ：key.c
	タイマ制御プログラム：timmer.c
	LCD 制御プログラム  ：lcd.c
	I/O 情報
		PA0-PA3：キーセンシング出力('0'でアクティブ)
		  PA3：SW1(1),  SW2(2),  SW3(3)  に接続
		  PA2：SW4(4),  SW5(5),  SW6(6)  に接続
		  PA1：SW7(7),  SW8(8),  SW9(9)  に接続
		  PA0：SW10(*), SW11(0), SW12(#) に接続
		P60-P62：キーセンシング入力('0'でアクティブ)
		  P60：SW1(1), SW4(4), SW7(7), SW10(*) に接続
		  P61：SW2(2), SW5(5), SW8(8), SW11(0) に接続
		  P62：SW3(3), SW6(6), SW9(9), SW12(#) に接続

  ・オルガンもどきプログラム
    D/A 変換を使って、押されたキーに対応する音階で波形を出力するプログ
    ラム。キースキャンと音程・音長の制御には多重割り込みを使用している。
    波形は 1 周期 8 点指定で、音程に応じて出力周期を割り込み制御する。
    音長とキースキャンは同じ割り込み周期で制御し、優先度は音程制御の割
    り込みが高くなっている。
	音程キー： *:C, 0:D, #:E, 7:F, 8:G, 9:A, 4:B
	発音キー： 1:長め, 2:短め
	オクターブキー： 5:下げる, 6:上げる
    音程キー + 発音キー で音が鳴る。オクターブキーを同時に押すと、1オ
    クターブ上がった(下がった)音で鳴る。但し、高いミ以上は正確でない。
	makefile : make-organ
	メインプログラム    ：organ.c
	音制御プログラム    ：sound.c
	D/A 制御プログラム  ：da.c
	キー制御プログラム  ：key.c
	タイマ制御プログラム：timmer.c
	LCD 制御プログラム  ：lcd.c
	I/O 情報
		P94：スピーカ切替え('0'で D/A 出力)

  ・音楽演奏プログラム
    D/A 変換を使って、予め入力されている音符データをもとに演奏を行うプ
    ログラム。基本部分はオルガンもどきプログラムと同様。演奏データは配
    列 score に入れておく。1 つの演奏データは、6 文字のフィールドから
    構成されていて、音程 1 2 3 音長 1 2 3 の順に並べて書く。
	音程 1 ：基本音階 C, D, E, F, G, A, B, 休符 N, 終了 Z
	音程 2, 3 ：オクターブ指定 +, -, 転調 #, b
	音長 1, 2 ：符長(一桁のときは前に0をつける)
	音長 3 ：符点 .
    プログラムでは、関数 score_init で初期化を行っている。演奏題目は木
    更津高専校歌「風のランナー」の 1 番。
	makefile : make-music
	メインプログラム    ：music.c
	音制御プログラム    ：sound.c
	D/A 制御プログラム  ：da.c
	キー制御プログラム  ：key.c
	タイマ制御プログラム：timmer.c
	LCD 制御プログラム  ：lcd.c
	I/O 情報
		P94：スピーカ切替え('0'で D/A 出力)

  ・音声録音再生プログラム
    A/D 変換とD/A 変換を使って、音声の録音・再生を行うプログラム。一定
    の割り込み間隔で、サンプリングと再生を行う。マイコン学習ボード上の
    スピーカは、マイクと兼用になっている。
	makefile : make-recorder
	メインプログラム    ：record.c
	A/D 制御プログラム  ：ad.c
	D/A 制御プログラム  ：da.c
	キー制御プログラム  ：key.c
	タイマ制御プログラム：timmer.c
	LCD 制御プログラム  ：lcd.c
	I/O 情報
		P94：スピーカ/マイク切替え('0'/'1')

  ・電卓ゲームもどきプログラム
    懐かしの電卓インベーダゲームを真似たプログラム。LCD の右側から表
    れる数字がインベーダで、刻々と左側に押し寄せてくる。照準キーでイン
    ベーダの数値と照準の数値を合わせてミサイルを発射して、壊滅させる。
    自陣側で撃ち落とした方が、より高得点になる。また、時折表れる UFO
    も他のインベーダよりも点数が高い。
	makefile : make-ufo
	メインプログラム    ：ufo.c
	D/A 制御プログラム  ：da.c
	キー制御プログラム  ：key.c
	タイマ制御プログラム：timmer.c
	LCD 制御プログラム  ：lcd.c
	乱数発生プログラム  ：random.c
	I/O 情報
		特になし

○Sフォーマットローダ
  マイコン学習ボードに付属の3052CPUボードに書き込まれているプログラム
  では、読み込みキャラクタの制限が厳しく、例えば CR や LF などのコード
  まで仕様に一致しないとエラーとなって動作してくれない。しかも、この仕
  様がどうなっているのかさえ、不明である。仮にわかっていたとしても、ホ
  スト計算機の OS やそのバージョンによって設定が異ることもあり、プログ
  ラム自体とは直接の係わりのない制御コードに悩まされるのは、非常に鬱陶
  しい。また、折角 USB ←→ シリアル変換をもっているのに、ホスト計算機
  とのプログラム転送は、扱い辛い E ケーブルで行うことになっている。滅
  多に ROM 化をしない学習ボードでは、これはデメリットでしかない。
  そこで、別途、USB 変換が接続されているシリアルポートからロード可能な、
  制御コードなどに左右されにくいSフォーマットローダを作成した。これで、
  ホスト計算機との接続は USB 接続ケーブル 1 本となり、飛躍的に扱いが良
  くなった。
  ・シリアルポートと ROM 化の関連について
    H8/300H シリーズのマイクロプロセッサには、フラッシュ ROM が搭載さ
    れている。これは、産業用途においては外付け部品はコスト高になるため
    であり、省スペース化を図る上でも有用である。このフラッシュ ROM に
    プログラム等を書き込む方法としては、専用のライタを用いる方法が一般
    的には考えられるが、開発コストが高くなる。このため、書き込むための
    手段として、H8/300H シリーズではシリアルポートからデータを読み込み、
    フラッシュ ROM に焼き込む方法がとられている。
    シリアルポートは SCI (シリアルコミュニケーションインタフェース)と
    表記されていて、H8/3052 では SCI0 と SCI1 の 2 ポートがある。この
    内、SCI1 がフラッシュ ROM を焼くときに使われる。したがって、マイコ
    ン学習ボードでも SCI1 に E ケーブルを接続するようになっている。
    一方、SCI0 には USB 変換 IC が接続されており、USB クライアントとし
    て動作できるようになっている。すなわち、マイコン側からは普通のシリ
    アル接続であるように見えていて、ホスト計算機側からは USB デバイス、
    または、仮想シリアルポート(どちらに見えるかは、ドライバによる)とし
    て見える。また、USB ポートからは、電源を供給してもらっている。
    マイコン学習ボードでは、ROM 化を行うことまでを考えて、プログラムの
    ダウンロードも含めて全て SCI1 側から行うように考えられているが、滅
    多に ROM 化の必要がない実験実習では、ケーブルを 2 本接続する意味も
    なく、断線し易い小型のコネクタのついた E ケーブルを扱うことはトラ
    ブルの種子を抱えることになる。
    このため、SCI0 側からダウンロードできるように、最初に一度だけ、フ
    ラッシュ ROM にローダを焼く手間が必要となる。
  ・ローダプログラム
    SCI0 ( USB 変換 IC 接続)から、モトローラの S フォーマット形式でプ
    ログラムをダウンロードするためのプログラム。ROM 化指定で make する
    必要がある。既に説明した手順に従って、フラッシュ ROM に焼くこと。
	makefile : make-loader
	メインプログラム    ：loader.c
	SCI0 制御プログラム ：sci0.c
	I/O 情報
		特になし
