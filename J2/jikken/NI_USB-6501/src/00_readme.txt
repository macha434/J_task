----- ----- ----- ----- ----- 
注意
----- ----- ----- ----- ----- 

  このファイルは，ここにアクセスすればいつでも閲覧できるので，いちいち
コピーすることを禁ずる。


----- ----- ----- ----- ----- 
Makefile の修正
----- ----- ----- ----- ----- 

BIN = write_data \
      read_data

all: $(BIN)


1.
  この BIN のところに，実行ファイル名となる名前を追加する。
　バックスラッシュは，次の行まで続くことを意味する。

BIN = write_data \
      read_data \
      LED_blink


2.
  コンパイル・ルールを追加する。
  行頭は TAB なので注意すること。

LED_blink: LED_blink_main.o \
	   $(LIBS)/niusb6501.o
	   gcc -o $@ $^ -lusb

  $@ → ターゲット名に置き換わる（この場合は LED_blink である）。

  $^ → 依存関係で置き換わる（この場合は LED_blink_main.o と
        $(LIBS)/niusb6501.o である）。

  -lusb  libusb.so という共有ライブラリ（システムで共通で使う道具箱）を使う。
         libusb.so は、USB に関する機能を提供する。

  gcc ... は，実際にコンパイルするコマンドである。
  依存関係は，$(LIBS)/niusb6501.o の行までであるので，この行末には
バックスラッシュは付けない。


----- ----- ----- ----- ----- 
ビットのローテートとは
----- ----- ----- ----- ----- 

  左ローテートさせると，最上位ビットの情報が最下位のビットに格納
される。

1001 1100
  ↓
0011 1001


----- ----- ----- ----- ----- 
ビット毎の OR とは
----- ----- ----- ----- ----- 

    uc_old    0 1 1 0 0 1 1 0
OR) uc_dat    1 0 0 0 0 0 0 0
  ---------------------------
    uc_now    1 1 1 0 0 1 1 0

  C言語では，パイプ記号 1つで表記する。

uc_now = uc_old | uc_now


  パイプ記号が 2つの場合は，論理の OR となるので，区別する
こと。
  例）  if ( a == 0 || b > 0 ) {
          ...
        }


----- ----- ----- ----- -----
ビットシフトとは
----- ----- ----- ----- -----  

  左シフトでは，ビットが 1つずつ左にずれる。

  1 0 0 1 0 1 1 0
　   ↓
  0 0 1 0 1 1 0 0

  最上位のビットの情報は捨てられ，最下位ビットには 0 が
セットされる。
  C言語では << を用いる。uc_old を 1 ビット左にシフトさせる
には，左シフト演算子 << の 右に 1 を与える。

uc_now = uc_old << 1;

  右シフト演算子は >> である。

uc_now = uc_old >> 1;


## EOF


